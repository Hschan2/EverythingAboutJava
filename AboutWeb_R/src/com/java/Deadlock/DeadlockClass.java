package com.java.Deadlock;

public class DeadlockClass {

	public static void main(String[] args) {
		// TODO Auto-generated method stub

//		교착 상태(Deadlock)
//		프로세스나 스레드가 결코 일어날 수 없는 특정 이벤트를 기다리는 상태
//		(예. 꽉 막힌 도로 -> 누군가 해결할 사람이 나오지 않으면 해결 불가능)
//		(예. 배터리가 방전된 노트북 소유 A, 배터리 충전기를 가지고 있는 B => 프로세스는 서로 공유하는 개념이 부족함
//			=> A는 노트북을 점유하고 B의 배터리를 대기, B는 배터리를 점유하고 A의 노트북을 점유 => 교착 상태)
//		
//		실제 시스템에서의 교착 상태
//		MySQL - 상호 거래 패턴
//		
//		교착 상태 네 가지 필수 조건
//		1. 상호 배제 조건(Mutual Exclusion Condition) - 여러 프로세스가 한 가지 자원에 접근하지 못하도록 막는 방법 => 한 번에 한 자원 접근 가능하여 교착 상태
//		2. 점유와 대기 조건(Hold-and-Wait Condition) - 한 프로세스가 한 자원을 점유하고 있는 상태로 다른 프로세스가 계속 대기 상태
//		3. 비선점 조건(Nopreemption Condition) - 프로세스가 자원을 할당 받으면 작업을 완료할 때까지 자원을 뺏을 수 없기 때문에 교착 상태
//		4. 순환 대기 조건(Circular-Wait Condition) - 점유와 대기 상태로 사이트에 갇혀서 빠져나갈 수 없는 상태
//		
//		교착 상태 해결법
//		교착 상태 예방
//		교착 상태는 필요악
//		필요 조건 중 하나를 거부하고 예방 -> (예.)점유와 대기 조건을 거부한다면 자원을 효율적으로 사용할 수 없다.
//		(예. 도서관에서 3권의 책을 빌리겠다. 만약 3권 중 1권이라도 없으면 읽지 않겠다.)
//		
//		교착 상태 회피
//		교착 상태를 인정하고 피해가는 것
//		대표적으로 은행원 알고리즘
//			- 시스템을 안전 상태 / 불안전 상태로 구분하고 불안전 상태일 때는 교착 상태가 발생할 수 있기 때문에 대기
//			- 할당할 자원 수 고정, 프로세스 수 고정, 제한된 시간 안에 자원 반납 등 많은 조건 필요
//		교착 상태가 발생한 것 같을 때 탐지하고 복구하는 전략 vs 자원을 요청할 때마다 시스템의 상태를 판단하고 회피하는 전략
//		
//		교착 상태 탐지 및 복구
//		교착 상태가 자주 발생하는 시스템에서 일반적으로 사용하는 방법
//		
//		교착 상태 탐지 - 교착 상태 존재 여부 및 교착 상태에 연관된 프로세스와 자원을 알아내고 순환 대기 존재 여부에 초점을 맞춤
//					대표적인 방법으로 자원할당 그래프 소거 -> 오버헤드가 발생할 수 있기 때문에 얼마나 자주 탐지 알고리즘을 호출하는가 중요하고 주기적으로 자원 즉시 할당 여부와 CPU 이용률 기준
//		
//		교착 상태 복구 - 순환 대기를 깨서 교착 상태로부터 회복
//						- 순환 대기가 깨질 때까지 프로세스 종료
//						- 순환 대기에 포홤된 프로세스의 제어권을 뺏고 롤백
//					어떠한 프로세스를 희생양으로 삼고 제거 시스템마다 다른 기준으로 우선 순위에 따라 다름 (남은 수행 시간, 자원 유형의 수)
//					
//					MySQL - 트랜잭션 타임아웃 시 교착 상태 여부에 상관 없이 작업량이 가장 작은 트랙잭션을 롤백(교착 상태에서 벗어남)
//						  - 트랜잭션 크기는 삽입, 업데이트 또는 삭제 된 행수에 의해 결정
//					
//		교착 상태 무시
//		교착 상태가 드물게 발생하는 시스템에서 일반적으로 사용하는 방법
//		윈도우와 UNIX에서 사용
//		교착 상태 해결 비용 문제 - 교착 상태가 발생할 때 사용자가 프로세스를 죽이거나 시스템을 재부팅을 하는 방법으로 해결
//			
//		* 데이터 베이스에서 발생하는 사례가 많고 탐지 알고리즘 등 찾아 봐야 할 자료가 많음
	}

}
