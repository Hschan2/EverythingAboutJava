package com.java.buildanddistribution;

public class BuildandDistribution {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		
		// 빌드와 배포
		
		/*
		
		1. 빌드란? - 컴파일 그리고 빌드
		컴파일 - 작성한 소스 코드를 바이너리 코드(2진법, 0과1로 구성)로 변환하는 과정
		빌드 - 소스 코드를 실행 가능한 소프트웨어 산출물(jar, war)로 만드는 일련의 과정
		링크 - 여러 개로 분리된 소스 코드를 컴파일한 결과물들에서 최종 실행 가능한 파일을 만들기 위해 필요한 부분을 찾아서 연결해주는 작업
				컴파일이 된 작업물을 가지고 실행 가능한 파일로
		
		2. 빌드 도구 *자동화*
		소스 코드를 컴파일, 테스트, 정적 분석을 실시 실행 가능한 앱으로 자동 생성하는 프로그램
		계속해서 늘어나는 라이브러리의 자동 추가 및 관리
		라이브러리의 버전을 자동으로 동기화
		
		MAVEN -> 프로젝트에 필요한 종속성을 리스트 형태로 maven에게 전달해 종속성을 관리, XML, Repository를 가져올 수 있다. jar, class path를 선언하면 repository에서 자동으로 필요한 라이브러리 파일을 불러온다.
			-> 라이브러리가 서로 종속하면 xml이 복잡, 계층적 데이터를 표현하기 좋지만 플로우나 조건부 상황을 표현하기 어려움, 편리하지만 맞춤화된 로직 실행이 어려움
		
		GRADLE -> JVM 기반 빌드 도구, maven의 단점 보완, 오픈소스 기반 빌드 자동화 도구, groovy(JVM 위에서 작동하는 스크립트) 기반 DSL(통합 언어)로 작성, Build-by-convention을 바탕으로 -> 스크립트 규모가 작도 읽기 쉬움, 설정 주입 방식
		
		Gradle이 Maven보다 빌드에 소요되는 시간, 유연성, 종속성 관리가 뛰어나고 스크립트를 짧고 읽기 쉽다. 그리고 라이브러리 의존성 관리를 더 효율적이고 강력한 기능을 제공하고 버전 충돌 또한 관리
		
		3. 배포
		작성한 코드를 빌드하고 빌드가 완성된 실행 가능한 파일(Jar, War)을 사용자가 접근할 수 있는 환경(사용자가 이용할 수 있는 환경)에 배치하면 배포가 완료
			- JAR, WAR 파일을 WAS에 올리는 것이 배포
		
		git에 올려두고 코드가 제대로 동작하는지 테스트 코드를 작성하고 이를 수행 및 검증하는 작업까지 포함
		
		4. CI / CD
		CI -> 지속적 통합. 개발자를 위한 자동화 프로세스인 지속적 통합(지속적으로 에러 검사)으로 모든 개발이 끝난 후 코드 품질을 관리하는 고전 방식(마무리한 모든 코드를 마지막에 검사)의 단점을 해소하기 위해
			-> 코드를 통합, 통합한 코드가 제대로 동작하는지 테스트, 제대로 빌드가 되는지 테스트, 결과를 정리하고 버그가 존재하면 작성하는 것을 해결
		
		CD -> 지속적 배포. 소프트웨어가 항상 신뢰 가능한 수준(테스트 통과, 빌드 통과)에서 배포될 수  있도록 관리
			-> 지속적으로 통합하고 테스트와 빌드를 진행하고 이를 통과한 코드에 대해서 신뢰할 수 있고 바로 배포할 수 있음
		
		5. 무중단 배포
		기존 동작하고 있는 서버(배포가 완료된)가 존재했을 때 그 상태에서 새로 업데이트한 코드를 배포하면 충돌이 생긴다 -> 서버를 다시 내리고 코드를 다시 배포하고 다시 서버를 동작해야 한다
		8080포트에 서버를 띄우고 새롭게 배포할 내용이 있으면 포트 충돌을 막기 위해 서버를 내리고 8080포트에 새롭게 배포할 서버를 띄움 -> 서버가 다시 뜨는데 필요한 시간만큼 서비스가 불가능한 시간(다운 타임)이 발생한다
		이를 해결하기 위함
		
		* 무중단 배포의 필요 조건
		두 대 이상의 서버를 서비스
		다운 타임(서비스 이용 불가)이 발생하지 않으려면 실제 서비스 중인 서버와 새롭게 배포한 서버가 동시에 존재해야
		비용을 줄이려면 배포할 때만 새로운 서버를 띄우고 배포가 완료된 후에 기존 서버를 죽임
		
		1)Rolling 배포
		서버 1을 로드 밸런서에서 뺀다 -> 서버1에 배포 -> 서버1을 다시 로드 밸런서에 넣는다 -> 서버2를 로드 밸런서에서 뺀다 -> 서버2에 배포 -> 서버2를 다시 로드 밸런서에 넣는다
			- 배포할 서버가 너무 많으면 n대 단위로 배포하기도 하지만 배포가 모두 끝나기 전까지 이전 서비스를 받는 사람, 신규 서비를 받는 사람으로 나뉠 수 있는 문제가 발생한다
			- 1대에 배포하는 것 보다 최소 2배 이상 느리다
			
		2) Canary 배포
		소수의 유저(예. 사내)만 사용하는 환경에 신규 버전을 배포하고 문제가 없다고 판단됐을 때 다른 모든 서버에 배포
		
		3) Blue / Green 배포
		실제로 서비스 중인 환경(Blue)과 새롭게 배포할 환경(Green)을 세트로 준비해서 배포하는 방식 (가장 자주 보는 방식)
		 - 새롭게 배포할 환경에만 배포하면 되기 때문에 배포 속도가 매우 빠름
		 - 언제나 Green(새롭게 배포할 환경)이 떠있기 때문에 만약 잘못된 버전으로 배포했을 경우 신속하게 롤백(되돌리다)이 가능
		 - 다만 Green(새롭게 배포할 환경) 환경이 항상 떠있어야 하기 때문에 비용이 두 배로 든다
		
		*/
	}

}
