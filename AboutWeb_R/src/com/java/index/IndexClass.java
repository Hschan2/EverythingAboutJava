package com.java.index;

public class IndexClass {

	public static void main(String[] args) {
		// TODO Auto-generated method stub

//		인덱스
//		책에서의 목차와 같은 의미라고 생각하면 된다.
//		
//		인덱스 왜 사용?
//		사용자가 데이터를 요청할 때 디스크에 요청해서 다시 전달 받아오는 과정을 거쳐야 한다.
//		매번 이런 과정을 겪으면 낭비가 크다.
//		자주 사용하는 데이터를 메모리에 담아서 자주 사용하는 데이터를 요청할 때 빠르게 받아올 수 있다.
//		
//		그 동안 인덱스에 큰 신경을 쓰지 않았던 것은 작은 데이터만 요청하였기 때문
//		기업의 데이터는 대용량. 이를 요청하기 위해 전부 스캔하면 비효율적
//		때문에 인덱스를 만들어서 데이터를 관리 (인덱스를 메모리에 저장)
//		
//		Full Table Scan
//		데이터를 찾기 위해 모든 것을 스캔
//		대용량 데이터에 비효율적
//			
//		B-tree (인덱스 구조)
//		이진 트리와 비슷한 구조
//		자식노드의 개수가 2개 이상인 트리
//		
//		인덱스가 DB에서 어떻게 운영되는가?
//		수직적 탐색과 수평적 탐색으로 이루어짐
//		인덱스의 운행 방식은 수식적으로 조건을 만족하는 첫 번째 레코드를 찾아 들어간 후 리프 노드(최말단)에서 수평적으로 조건을 만족하는 레코드를 찾음
//		
//		* 데이터를 저장하는 가장 기본 단위 - 블록 혹은 페이지 => 데이터 읽기 쓰기 작업의 최소 단위
//		인덱스도 페이지 단위로 관리
//		
//		Range Scan
//		인덱스 루트 블록에서 리프 블록까지 수직적으로 탐색한 후에 리프 블록을 필요한 범위만 스캔하는 방식
//		Full Table Scan과 반대되는 개념
//		즉 효율적
//		
//		인덱스는 언제 사용?
//		DB에서 SELECT(FROM, WHERE과 함께 할 때) 할 때는 효율적이나 INSERT, UPDATE, DELETE 할 때는 비효율적(성능 저하)
//		
//		인덱스는 정렬된 상태로 저장되어야 하기 때문에 INSERT에서 성능 저하
//		인덱스는 테이블에도 저장 인덱스에도 저장되어야 하기 때문에 낭비
//		
//		인덱스는 실제로 지우는 것이 아니라 사용 안함으로 바뀌는 것이기 때문에 DELETE에서 성능 저하
//		
//		인덱스에는 UPDATE라는 정의가 없음
//		그래서 인덱스에서의 UPDATE는 DELETE를 하고 다시 INSERT를 하는 개념
//		
//		인덱스 Column 설정 기준은 기수성(Cardinality)가 높은 것부터
//			* 기수성 - 어느 그룹 안에 요소가 몇 개 있는지 그 숫자 (종류로 아는 것이 쉽다. 예를 들어 성별로 볼 때 남, 녀 2개지만 주민번호로 볼 때는 여러 개)
//		특정 데이터를 조회할 때 고유 번호로 조회하는 것이 유용
//		기수성은 높다 낮다가 아닌 데이터를 비교해서 찾는 것이 좋음
//		결론적으로 기수성이 높은 것을 인덱스 컬럼 기준으로 해야 원하는 값을 쉽게 찾을 수 있다
		
	}

}
