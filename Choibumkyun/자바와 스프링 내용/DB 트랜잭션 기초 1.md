# DB 트랜잭션 조금 이해하기

## 트랜잭션
클라이언트가 서버에 요청 -> 서버가 데이터 베이스에 요청 -> 데이터 베이스의 데이터를 서버에 응답 -> 서버는 데이터를 클라이언트에 응답   

* 여러 읽기 / 쓰기를 논리적으로 하나로 묶은 것
    * 트랜잭션 시작 - 여러 개의 쿼리 실행 - 커밋 또는 롤백
    * 모두 반영(커밋) 또는 모두 반영하지 않음(롤백)   

<B>트랜잭션이 만약에 없다면?</B>   
문제 발생 시, 애플리케이션이 데이터 일관성을 보장해야 한다.   

## 트랜재션 범위
트랜재션의 범위는 커넥션 기준으로 한다는 것을 알고 있어야 한다.   

즉, 여러 메서드를 호출할 때, 다양한 메서드를 하나의 트랜잭션으로 묶고 싶다면 여러 메서드에서 하나의 커넥션을 사용할 수 있는 방법이 필요하다는 것을 뜻한다.   

## 트랜잭션 전파
* 여러 메서드 호출이 한 트랜잭션에 묶이도록 하기 위해 필요하다.
    * 예 - 스프링 프레임워크의 트랜잭션 처리
        * 메서드 간에 커넥션 객체를 전달하지 않아도 한 트랜잭션으로 묶어서 실행   

```
@Transactional // 트랜잭션 활성화
public void crate() {
    if (dao.checkDuplicate(req.getEmail())) {
        throw new DupEmailException();
    }

    ...

    dao.insert(member);
}
```

```
public boolean checkDuplicate(String email) {
    return jdbcTemplate.queryForObject(...) > 0;
}
```

```
public void insert(Member m) {
    jdbcTemplate.update(...);
}
```

## 트랜잭션과 외부 연동
* 외부 연동이 섞여 있으면 롤백 처리에 매우 주의해야 한다.
* 외부 API를 가져오는 작업이 재대로 수행 후 그 다음 작업에서 호출 문제가 생겼을 때는 외부 API 호출에 대한 롤백은 하지 않기 때문에 문제가 발생할 수 있다.   

## 글로벌 트랜잭션
* 2 PC (Two-phase Commit)
* 두 개 이상 자원(DB, 메시징큐 등)을 한 트랜잭션으로 처리
    * 각 자원이 2 PC를 지원해야 한다.
    * 글로벌 트랜잭션 관리자가 필요하다.
    * 두 개 이상 자원에 대한 트랜잭션 처리가 쉬워진다.
* (거의) 사용하지 않음
    * 성능이 떨어진다. (서비스 / 마이크로서비스)
* 다중 자원에 대한 데이터 처리가 필요하면 다른 수단 고려
    * 예. 이벤트 / 비동기 메시징   

## 정리
* 원자성(Atomicity) - <b>A</b>CID
    * All or Nothing (모두 반영하거나 모두 반영하지 않거나)
* 트랜잭션 범위 중요
    * 문제가 발생했을 때, 롤백해야 하는 범위
* 다음 초식은 트랜잭션 격리 / 동시성

[DB 트랜잭션 조금 이해하기](https://www.youtube.com/watch?v=urpF7jwVNWs&t=5s)