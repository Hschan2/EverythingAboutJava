package com.java.Serialization;

public class SerializationClass {

	public static void main(String[] args) {
		// TODO Auto-generated method stub

//		자바 직렬화란?
//		객체 상태를 영속화 하는 메커니즘
//		즉, 객체를 다른 환경(파일, 메모리, DB...)에 저장하고 나중에 재구성 할 수 있게 만들어주는 과정
//		
//		자바에서의 자바 직렬화?
//		쉬운 분산 객체 생성, Byte Stream
//		
//		언제 사용하나?
//		객체 상태를 영속할 필요가 있을 때. 즉, 어딘가 저장해야 할 필요가 있을 때 사용한다. (파일 혹은 DB, 메모리 등)
//		정보 전달할 필요가 있을 때 (바이트 스트림으로 변환해서 전송할 때)
//		
//		어떻게 사용하나?
//		우선 Serializable 인터페이스를 클래스에서 Implements 한다
//		여기서 Serializable 인터페이스는 단순 마커 인터페이스지만 이렇게 사용하지 않을 경우 NotSerializableException이 발생한다.
//		
//		직렬화 하는 방법은?
//		ObjectOutputStream의 writeObject를 이용해서 객체를 직렬화 한다.
//		그리고 ByteArrayOutputStream을 이용하고 ObjectOutputStream() 안에 ByteArrayOutputStream 넣는다
//		그리고 toByteArray() 메서드를 이용해서 직렬화된 바이트 스트림을 얻을 수 있다.
//		
//		반대로 역직렬화 하는 방법은?
//		ObjectInputStream을 이용한다.
//		ObjectInputStream에서 readObject()을 이용해 직렬화된 정보를 이용해 객체로 역직렬화를 한다.
//		
//		직렬화와 역직렬화의 흐름은?
//		객체는 writeObject를 거쳐 직렬화가 되고 어딘가에 보관되어 있다가 readObject에서 역직렬화가 되어 객체로 재생성된다.
//		
//		그런데 왜 잘 안쓸까?
//		1. 보안
//		역직렬화를 위해 readObject를 할 때 생성자를 만드는데 이를 보이지 않는 생성자라고 한다.
//		생성자를 만들고 생성자에 값을 넣어주어야 하는데 이를 위해서 Validation 작업이 필요하다.
//			예들 들어 만약 객체를 직렬화하여 getSerializedObject 값을 1로 생성했을 때  역직렬화 후 값이 -1인지 검사를 하면 실패한다.
//			이유는? 객체를 직렬화할 때 값인 1을 역직렬화 하였기 때문
//			만약 해커가 직렬화한 값 1을 임의로 -1로 변경했을 경우 역직렬화한 값이 -1이 되어 테스트는 통과하게 된다. => 원하는 Validation 로직이 적용되지 않았기 때문
//			이를 예방하기 위해서 커스텀 직렬화를 사용하면 된다.
//		커스텀 직렬화 - 직렬화 대상 클래스에 readObject 메서드를 새롭게 정의하면 된다.
//		커스텀 직렬화에 objectInputStream.defaultReadObject()를 수행하면 기본적인 역직렬화가 먼저 실행된다. (ObjectInputStream의 readObject 메서드와 동일한 일을 수행)
//		
//		2. 싱글톤 문제
//		기본적으로 readObject를 하면 직렬화와 역직렬화가 서로 다른 객체로 생성된다. -> 서로 다른 객체를 생성했다는 것은 싱글톤을 잃어버린 것과 같다.
//		즉, 싱글톤을 직렬화 한 후 역직렬화를 하니 객체가 서로 다른 객체가 되었다.
//		이를 해결하기 위해서 readResolve를 사용하면 된다.
//		readObject 후 readResolve를 하면 역직렬화 하여 생성한 객체는 더 이상 사용하지 않고 readResolve에서 내보내는 객체를 사용한다.
//		다만 이를 사용하기 위해서 transient 예약어를 사용해서 직렬화-역직렬화 대상이 되지 않도록 해야 한다.
//		그렇지 않으면 참조 필드의 영역 값을 훔쳐오는 행위가 가능하다 (해킹 위험)
//			* 자세한 내용은 도둑 클래스 구현 방법을 검색하자
//		싱글톤과 같이 객체의 갯수를 통제해야 하는 경에는 열거형인 enum(원소 하나를 가짐)을 사용하는 것이 좋다.
//		싱글톤을 구현하면 직렬화-역직렬화에서 발생하는 문제들이 해결되는 싱글톤을 구현할 수 있다.
//		
//		3. 보안 - 직렬화 프록시 패턴
//		위에 1. 보안에서 직렬화-역직렬화를 할 때 원하는 Validation 로직을 사용할 때는 사용할 때마다 중복해서 사용해야 한다. 이것이 여러 번 하게 되면 실수하게 된다.
//		이 실수를 방지하는 방법 중 직렬화 프록시 패턴이 있다.
//		기존 사용했던 클래스(이제는 외부 클래스라 부르고)를 사용하지 않고 프록시 객체를 만드는 Proxy 클래스(중첩 클래스라 부르겠다)를 사용하여 직렬화-역직렬화 할 때 사용한다.
//		Proxy 클래스는 기존 클래스의 대리 역할이다.
//		
//		readResolve가 역직렬화 과정에 간섭해서 원하는 객체를 역직렬화 대상으로 갈아 끼운 것이라면
//		writeReplace는 직렬화 과정에 간섭해서 특정 객체를 직렬화 결과로 반환할 수 있다.
//		그리고 한 가지 더 추가해야 한다.
//		중첩클래스 (대리 역할)를 직렬화하였기 때문에 역직렬화는 중첩클래스에서 일어난다.
//		역직렬화 할 때 중첩 클래스의 readResolve를 사용한다.
//		그러나 우리가 실제로 사용하려는 객체는 외부 클래스. 즉  기존에 사용했던 클래스이다. 그래서 외부 클래스를 역직렬화 하도록 생성자를 생성한다(중첩 클래스 안에).
//		이렇게 하면 Validation 로직을 중복해서 불렀던 것을 외부 클래스의 생성자에서만 사용하게 되면서 관리 포인트가 감소한다.
//		
//		직력화-역직렬화 흐름 정리
//		Object -> writeObject(커스텀 직렬화) -> writeReplace(직렬화 대상 바꾸기) -> 어디엔가 보관 -> readObject(커스텀 역직렬화) -> readResolve(역직렬화 대상 바꾸기)
//		
//		* 유지보수성, 테스트, 그 외 다수 (예. 싱글톤 문제, 역직렬화 폭탄...)
//		
//		이러한 이유로 평소에 잘 사용하지 않는 자바 직렬화를 꼭 써야 한다면?
//		아주 아주 잘 써야 한다. (커스텀 직렬화 잘 쓰기, 직렬화 프록시 잘 쓰기, 역직렬화 필터링 잘 쓰기, 직렬 버전 관리 잘 하기....)
//		더 좋은 방법을 위해 이펙티브 자바를 읽어보면 좋다.
//		
//		자바 직렬화보다 좋은 방법이 있나?
//		자바 직렬화를 사용하지 않는 것 -> 새로운 자바 시스템에 바이트 스트림으로 변환할 수 있는 좋은 메커니즘이 많다. (jSON을 이용한 방법)
		
	}

}
