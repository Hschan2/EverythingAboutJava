package com.java.TestIsolation;

public class TestIsolationClass {

	public static void main(String[] args) {
		// TODO Auto-generated method stub

//		테스트 격리
//			* 테스트 - 순서에 상관없이 독립적으로 실행되며 결정적으로 수행되어야 함
//			여기서 결정적으로 수행 - 같은 입력 값이면 언제나 같은 결과 반환
//		일반적으로 Strping Boot, JUnit에서 테스트 격리를 지원 (어노테이션이 격리를 지원하는 도구를 제공)
//		
//		테스트 격리 필요 이유
//		각각 테스트에서 사용된 데이터들이 공유되기 때문에 이 데이터들이 언제 어떻게 사용될지 모르기 때문에 사용
//		
//		DB에 의존하지 않고 얼마나 테스트를 할 수 있는가
//		도메인 테스트(POJO) (순수 자바 객체, Entity나 VO 유틸성 객체를 의미s)
//		POJO는 JUnit으로 테스트 - 객체는 new 연산자로 간단히 인스턴스화
//							- 각각의 테스트가 실행되기 전에 @BeforeEach에서 인스턴스 초기화(항상 같은 값으로 객체 초기화되기 때문에 모든 테스트가 똑같은 환경에서 수행)
//							- 데이터베이스를 사용하지 않기 때문에 격리 걱정 필요 없음
//		
//		서비스 테스트
//		서비스 계층 - 실질적으로 비즈니스 로직을 수행, 실제 DB를 사용, 트랜잭션이 끝나면 DB 상태 변경, 테스트 간 격리 필요한 계층
//		서비스 객체 메서드를 테스트하려면 빈을 받는 등 과정이 있음 (Service Bean을 @StringBootTest로 빈을 주입)
//		이는 실제 DB를 사용하면서 계층 구조롤 이루기 때문에 사실상 통합 테스트가 된다.
//		(@Transactional을 이용해 테스트가 종료되면 Rollback이 가능 - DB를 원상 복구) - 실제로 DB 상태를 변화시키지 않고 상황을 연출
//		BUT 대규모 DB를 테스트할 일이 아직 없기 때문에 Unit Test(단위 테스트)로 진행해야 하는데 이 때 Mockito(프레임워크)를 이용해 해결할 수 있다.
//			=> 실제 DB를 사용하지 않기 때문에 격리에 신경 쓸 필요 없음
//		
//		컨트롤러 테스트
//		원래는 컨트롤 빈을 직접 주입 받아서 표현 계층 ~ 데이터 접근까지 모든 빈들을 띄운 상태에서 테스트 로직을 수행해야 한다. (@StringBootTest 사용)
//		실제 DB를 사용하면 통합 테스트가 된다.
//		BUT, TDD를 사용하면 MockMvc(요청과 응답을 테스트하는 컨트롤러, Rest API)를 사용할 수 있다.
//		Mock을 사용하기 때문에 실제 DB를 사용하지 않고 테스트 격리에 신경 쓸 필요 없다.
//		@WebMbcTest 사용
//		
//		레파지토리 테스트
//		@DataJpaTest를 사용하면 전체 빈을 사용하지 않고 데이터 계층에서 필요한 빈들만 가지고 슬라이스 테스트를 할 수 있다.
//		InMemory로 테스트를 수행하고 자동으로 @Transactional(rollback = true)가 사용된다.
//		마찬가지로 테스트 격리를 신경 쓸 필요가 없다.
//		
//		인수(Acceptance) 테스트
//		시스템이 실제 운영 환경에서 사용될 준비가 되어 있는지 최종적으로 확인하는 단계
//		Mock 프레임워크를 사용하면 실제 DB를 사용하지 않는다는 점, 격리를 신경 쓸 필요가 없다는 점이 있지만 실제 운영 환경에서도 제대로 돌아가는지 알 수 없다.
//		그렇기 때문에 사용자의 실제 운영 환경에서 돌아가는지 확인하기 위해 인수 테스트를 진행한다.
//		목적 - 사용자 시나리오에 맞춰 잉ㄴ수 조건을 도출하고 실제 운영 환경에 맞게 서버를 띄운 상황에서 테스트를 한다.
//		@SpringBootTest를 이용해 모든 빈을 띄어야 하므로 Mock 프레임워크를 사용할 수 없다. -> 실제 DB 데이터가 변할 수 있다. 그래서 데이터 사용의 동의를 고려해 줘야 하는 대상이 된다.
//		테스트 격리를 신경쓰지 않으면 테스트가 실패하기 쉽고 테스트 단위가 크기 때문에 한 번 실패하면 디버깅하는 것이 까다로워 진다.
//		
//		인수테스트에서 격리할 수 있는 방법
//		1. @Transactional (롤백 제공)
//		다만 이 방법은 인수테스트에서 제대로 동작이 안 될 수 있다. => 서버를 띄우고 요청을 하면 실제 수행하는 서버로 각 다른 쓰레드가 실행이 된다. => 롤백 전략을 가져간다고 해도 다른 쓰레드에서 실행되는 서버사이드 트랜잭션은 테스트에 제대로 영향을 받지 않아 롤백 전략이 되지 않고 DB 상태가 된다.
//		Transactional의 사용 출처에서 같아도 차이가 나기 때문이다. => SpringTestContext에서 프레임워크가 테스트에서 트랜잭셔널을 별도로 관리하기 때문
//		
//		2. 매번 테스트 종료 시 생성한 픽스처 및 데이터 삭제
//		장점
//		비교적 간단하며 일반적으로 사용하는 방식
//		인수 조건을 테스트할 때 필요한 픽스처가 적은 경우 유용하다.
//		
//		단점
//		생성해야 할 픽스처가 많거나 연관 관계 맵핑 시 비효율적이다.
//		
//		단점의 예시로
//		JUnit의 라이프 사이클을 이용해 BeforeEach로 사용할 픽스처를 생성 요청을 보내고 테스트가 종료되는 시점에 AfterEach를 하여 라이프 사이클에서 픽스쳐 삭제를 요청하면 일부 데이터가 삭제되지 않을 수 있다.
//		픽스처가 많을 경우 테스트만을 위해 사용한다면 비용 문제가 크다. (테스트 성능 저하)
//		
//		3. 매번 테스트 종료 시 테이블 트런케이트(Truncate)
//		데이터를 지울 때 Truncate를 하지 않고 Delete를 할 수 있다.
//		다만, 데이터를 지울 때 Delete보다 Truncate가 좋다.
//			1) 트랜잭션 로그 공간을 적게 차지한다.
//			2) 쿼리 실행 시 행 단위로 락을 걸지 않는다. (속도 빠름)
//		
//		Truncate 사용 방법
//		1. @Sql로 SQL 파일 실행
//		사용하고자 하는 sql를 미리 작성을 하여 테스트 직전에 sql문을 사용한다.
//		엔티티나 연관 관계 테이블이 추가, 수정, 삭제될 때마다 SQL 파일 수정이 필요하다는 단점이 있다.
//		
//		2. EntityManager 사용
//		쿼리를 직접 만들어서 직접 사용할 수 있는 빈을 가리킨다.
//		빈을 이용해서 초기화 로직을 생성해 놓는다. => 추후 엔티티가 추가 혹은 삭제가 될 때 동적으로 테이블 이름을 조사하기 때문에 격리되어 투입되는 비용이 절감된다.
//		
//		이 외에 DirtyText, Annotation 방법도 있다. => 테스트를 끝날 때나 수행할 때마다 텍스트 전체를 다시 Load하는 기능을 한다.
//		=> DB가 다시 생성디고 테이블이 Sql로 초기화되어 별도 작업없이 가장 단순하고 깔금하게 시행 가능하지만 테스트 시간이 길어진다. => 비추천
//		
//		결론
//		잘 격리된 테스트는 유지 보수가 수월하고 더욱 안전한 테스트를 작성하여 코드 품질을 향상시킨다.
	}

}
