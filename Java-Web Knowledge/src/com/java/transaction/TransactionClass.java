package com.java.transaction;

public class TransactionClass {

	public static void main(String[] args) {
		// TODO Auto-generated method stub

//		트랜잭션
//		여러 쿼리를 논리적으로 하나의 작업으로 묶는 것
//		
//		ex. 거래가 일어날 때의 과정
//			- 구매자 계좌에서 만원 출금 => update문 : 구매자 계좌에서 만원 빼기
//			- 판매자 계좌에 만원 입금 => update문 : 판매자 계좌에 만원 더하기
//				=> 두 과정을 하나로 묶은 것이 트랜잭션
//			BUT. 오류가 발생할 수 있다. 예) 구매자 계좌에서는 만원이 출금되었으나 판매자 계좌에 만원이 입금되지 않는 오류
//			이러한 오류를 예방하기 위해 사용하는 것이 트랜잭션(단위로 묶어 쿼리를 한 번에 모두 실행하거나 모두 실행안하는 것)
//			시스템에 문제가 발생해도 안정적으로
//			
//		* 하나의 트랜잭션은 커밋(DB에 실제 반영) 혹은 롤백(취소하고 DB를 기존으로)이 된다!
//		
//		ACID (트랜잭션 성질 1) = 이론적으로 보장해야 하는 성질
//		트랜잭션이 안전하게 수행된다는 것을 보장하기 위한 성질
//		
//		1) (원자성) 트랜잭션은 DB에 모두 반영되거나 전혀 반영되지 않아야 한다. (완료되지 않은 트랜잭션은 DB에 반영해서는 안 된다)
//		2) (일관성) 트랜잭션 작업처리 결과는 항상 일관성이 있어야 한다. (DB는 항상 일관된 상태로 유지되어야 한다. 조건을 만족하지 않을 경우 바로 종료)
//		3) (독립성) 둘 이상의 트랜잭션이 동시 실행되고 있을 때, 다른 트랜잭션은 기존 트랜잭션 연산에 끼어들 수 없다.
//		4) (지속성) 트랜잭션이 성공적으로 완료했으면 결과는 영구 반영되어야 한다.
//
//		실제로는 성능을 위해 손실 보장이 완화
//		예를 들어 독립성을 보장하기 위해 동일 데이터에 100개의 연결이 접근할 때 이는 순차적으로 하여야 한다 => 동시성이 떨어짐
//		
//		동시성을 얻기 위해 트랜잭션 격리 레벨을 설정
//		
//		트랜잭션 격리 수준
//		동시에 DB에 접근하려고 할 때 접근을 어떻게 제어하는지 설정
//		
//		- READ-UNCOMMITTED 동시성 최고
//		- READ-COMMITTED
//		- REPEATABLE-READ
//		- SERIALIZABLE 데이터 정합성 최고 (격리 수준이 높아지지만 성능 하락)
//		
//		READ-UNCOMMITTED
//		커밋 전 트랜잭션의 데이터 변경 내용을 다른 트랜잭션이 읽는 것을 허용
//		기존 트랜잭션이 롤백했을 경우 다른 트랜잭션이 이를 읽을 때 무효된 데이터를 읽기 때문에 Dirty Read가 생김
//		논 리피터블 리드 문제와 센텀 리드 문제도 나타남
//		
//		READ-COMMITTED
//		커밋이 완료된 트랜잭션의 변경 사항만 다른 트랜잭션에서 조회 가능
//		트랜잭션이 이루어지는 동안 다른 사용자는 이에 접근 불가
//		논 리피터블 리드 문제와 센텀 리드 문제가 나타남
//		
//		논 리피터블 리드 - 같은 데이터를 조회했을 때 두 값이 다른 값으로 나오며 데이터 불일치 문제
//		
//		REPEATABLE-READ
//		트랜잭션 범위 내에서 조회한 내용이 항상 동일함을 보장
//		커밋이 완료된 데이터만 조회 가능
//		한 번 조회한 데이터는 앞으로도 조회해도 같은 데이터를 반환
//		센텀 리드가 발생
//		
//		센텀 리드 - 조건이 걸리든 아니든 SELECT문을 사용할 때 나타날 수 있는 현상
//		해당 쿼리로 읽히는 데이터에 들어가는 행위이며 새로운 것이 생기거나 기존 것이 없어져 있는 현상
//		
//		SERIALIZABLE
//		한 트랜잭션에서 사용하는 데이터를 다른 트랜잭션에서 접근 불가
//		
//						진행 중인 트랜잭션 유					진행 중인 트랜잭션 무
//						
//		REQUIRED		해당 트랜잭션 사용					새로운 트랜잭션 생성
//		MANDATORY		해당 트랜잭션 사용					예외 발생
//		REQUIRES_NEW	해당 트랜잭션 보류, 새로운 트랜잭션 생성	새로운 트랜잭션 생성
//		SUPPORTS		해당 트랜잭션 사용					트랜잭션 없이 진행
//		NOT_SUPPORTED	해당 트랜잭션 보류					트랜잭션 없이 진행
//		NEVER			예외 발생							트랜잭션 없이 진행
//		NESTED			중첩 트랜잭션 생성					새로운 트랜잭션 생성
	}

}
