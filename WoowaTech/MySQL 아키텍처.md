# MySQL 아키텍처
* MySQL 아키텍처 구분
    * MySQL 접속을 위한 클라이언트
    * MySQL 엔진 (핸들러  API)
        * 쿼리 파서
        * 전처리기
        * 옵티마이저: 요청된 SQL 문을 최적화하여 실행시키기 위해 실행 계획을 하는 중요한 역할
        * 실행 엔진
    * MySQL 스토리지 엔진 (핸들러  API): MySQL의 손발 역할을 담당. 데이터를 실제로 디스크에 저장하거나 디스크에 저장된 데이터를 읽어오는 역할
    * 운영체제, 하드웨어   

## 쿼리 실행 과정
1. 쿼리 캐시   
    * SQL 실행 결과를 메모리에 캐싱하는 역할
    * 동일 SQL 실행 시 이전 결과 즉시 반환
    * 테이블의 데이터가 변경되면 캐싱된 데이터 삭제가 필요 (동시 처리 서능 저하)
    * MySQL 8.0부터 완전히 제거: 캐싱 데이터가 삭제될 때마다 쿼리 캐시에 접근하는 스레드에 Lock이 걸리는 것이 성능 저하를 유발하기 때문에   
2. 캐시 파서   
    * 기본적인 SQL 문장 오류 체크
    * SQL 문장을 토큰으로 쪼개어 트리로 만듦: MySQL은 Parse Tree를 사용하여 쿼리 실행
    * 해당 과정에서 쿼리 문장의 기본 문법 오류를 확인   
3. 전처리기   
    * Parse Tree를 기반으로 SQL의 문장 구조를 확인
    * Parse Tree의 토큰이 유효한지 확인: 토큰에 해당하는 테이블명이나 컬럼 등이 실제로 존재하는 값인지 확인하고 접근 권한도 확인   
4. 옵티마이저   
    * SQL 실행을 최적화해서 실행 계획을 수립
    * SQL 최적화
        * 규칙 기반 최적화
            * 옵티마이저에 내장된 우선 순위에 따라 실행 계획 수립
        * 비용 기반 최적화
            * 작업의 비용과 대상 테이블의 통계 정보를 활용해서 실행 계획 수립   
5. 쿼리 실행 엔진   
    * 쿼리 수행 역할
    * 옵티마이저가 만든 실행 계획대로 스토리지 엔진을 호출해서 레코드를 읽고 사용   
6. 스토리지 엔진   
    * 쿼리 실행 엔진을 요청하는대로 데이터를 디스크로 저장하고 읽음
    * 핸들러 API에 의해 동작
    * 핸들러라고도 부름
    * 플러그인 형태로 제공
        * 검색어 파서, 사용자 인증 모듈 등 제공하지만 플러그인끼리 통신이 불가하고 MySQL 서버의 변수나 함수를 직접 호출하기 때문에 캡슐화를 위반하는 단점 존재
    * InnoDB, MyISAM 스토리지 엔진   

## InnoDB 스토리지 엔진 아키텍처
InnoDB의 핵심적인 특징은 다음과 같다.   

* 기본키(프라이머리 키)에 의한 클러스터링
* 트랜잭션 지원 (MVCC, 리두 로그와 언두 로그, 레코드 단위 잠금)
* InnoDB 버퍼풀과 어댑티브 해시 인덱스   

그리고 PK에 의한 클러스터링의 특징을 가지고 있다. 더욱 자세한 내용은 다음과 같다.   

* 레코드를 PK순으로 정렬해서 저장
* PK 인덱스 자동 생성
* PK를 통해서만 레코드에 접근 가능
* PK를 통한 범위 검색이 매우 빠름
* 그러나 클러스터링 때문에 쓰기 성능이 저하
    * PK값이 변경될 경우 물리적인 레코드 순서도 수동으로 변경해야 하기 때문
    * InnoDB에서 PK값을 직접 설정하지 않으면 자동으로 설정해주지만 이는 직접 변경이 불가능하기 때문에 PK값을 직접 설정하는 것이 효율   

그리고 InnoDB는 기본적으로 트랜잭션의 <b>Commit</b>과 <b>Rollback</b> 기능을 제공한다. 또한 <b>MVCC(Multi Version Concurrency Control)</b> 기능 또한 제공한다. [정확한 예시로 이해하기](https://youtu.be/vQFGBZemJLQ?t=344) 쉽게 말하면 트랜잭션 격리 레벨에 따라 조회되는 데이터가 달라지게 하는 기술을 <b>MVCC</b>라고 한다.   

InnoDB 스토리지 엔진 특징 중 트랜잭션에서 <b>언두 로그</b>와 <b>리두 로그</b>가 있다.   

* 언두 로그(Undo Log)
    * 변경되기 이전 데이터를 백업
    * 트랜잭션 보장 (Rollback 시 언두 로그에 백업된 데이터 복원)
    * 트랜잭션 격리 수준 보장 (트랜잭션 격리 수준에 맞게 백업된 데이터 반환)
* 리두 로그(Redo Log)
    * 변경된 데이터를 백업 (Control 안료된 데이터)
    * 영속성 보장 (서버의 비정상 종료 시 리두 로그에 백업된 데이터 복원)   

또한, 트랜잭션에서 레코드 단위 잠금 기능을 제공한다. 이는 레코드 단위로 잠금을 걸기 때문에 <b>동시 처리 성능</b>이 좋다. 여기서 레코드 자체를 잠그는 것이 아닐 <b>인덱스</b>를 잠그는 것이다. 여기서 <b>잠금</b>은 데이터 베이스에서 데이터를 변경할 때 동시성 문제를 고려하여 레코드에 대한 잡근을 막는 것을 말한다. [레코드 단위 잠금 상황 예시](https://youtu.be/vQFGBZemJLQ?t=497)   

그리고 InnoDB 스토리지 엔진 특징 중 <b>버퍼풀</b>이라는 것이 있다. 버퍼풀은 디스크의 데이터 파일이나 인덱스 정보를 메모리에 캐싱해두는 공간을 말한다. 버퍼풀의 용도는 두 가지가 있다.   

* 데이터 캐싱
    * 인덱스 정보와 데이터 파일을 메모리에 캐싱
    * 페이지 단위로 테이블 데이터를 관리
    * 페이지 교체 알고리즘으로 LRU 사용
* 쓰기 지연 버퍼 (일괄적 작업 처리)
    * 변경된 데이터(더티 페이지)를 버퍼풀에 모았다가 한 번에 디스크에 기록 => 랜덤 I/O를 줄이기 위해
    * JPA 영속 컨텍스트의 쓰기 지연 SQL 저장소랑 비슷   

그리고 버퍼풀에서 <b>어댑티브 해시 인덱스</b>가 있다. 어댑티브 해시 인덱스는 인덱스 키와 페이지의 주소값 쌍으로 구성된 인덱스이다. 어댑티브 해시 인덱스의 특징은 다음과 같다.   

* 페이지에 빠르게 접근하기 위한 해시 자료구조 기반 인덱스
* <인덱스 키, 페이지 주소 값> 쌍으로 구성
* 자주 요청되는 페이지에 대해 InnoDB가 자동으로 생성하는 인덱스   

## MyISAM 스토리지 엔진 아키텍처
MyISAM의 핵심 특징들은 다음과 같다.   

* 클러스터링 지원하지 않음
* 트랜잭션 지원하지 않음
* 외래키 지원하지 않음
* 테이블 단위 잠금으로 동시 처리에 불리
* 키 캐시 사용 (인덱스 정보만 버퍼링)
* 전문 검색, 공간 좌표 검색 기능 지원   

## InnoDB vs MyISAM
||InnoDB|MyISAM|
|!---!|!---!|!---!|
|클러스터링 테이블(인덱스)|O|X|
|외래키 설정 지원|O|X|
|트랜잭션 지원|O|X|
|Locking Level(잠금 방식)|레코드 단위 잠금|테이블 단위 잠금|
|데이터 캐싱|버퍼풀 사용(인덱스, 테이블 데이터 캐싱|키 캐시 사용(인덱스 캐싱)|   

MySQL 8.0 버전 이후로 MyISAM의 기능을 InnoDB에서도 모두 사용할 수 있게 되었고 이후 MyISAM의 사용은 줄어들고 InnoDB의 위주로 사용하게 될 것임이 보인다.   

[MySQL 아키텍처](https://www.youtube.com/watch?v=vQFGBZemJLQ)