# OOP: 객체지향 프로그래밍

## 객체지향 프로그래밍
1. 프로그래밍 개발 방법론   
2. 사람이 현실을 바라보는 개발에 접목   
    1. 직관적으로 이해하기 쉽다.   
    2. 유지 보수를 용이하게 만든다.   

### 키워드로 객체지향 알아보기
* 객체
* 협력과 책임, 역할
* 메세지
* 자율성(의인화)
* 다형성

#### 객체
* 현실의 무언가에 대응하는 개념
* 'class'는 객체를 표현하는 하나의 수단 (class != 객체)   

#### 협력과 책임, 역할
객체는 다른 객체와 <b>협력(Collaboration)</b>하는 <b>역할(Role)</b>을 맡고 있는 대상이며 역할을 맡으면 임무를 수행할 <b>책임(Responsibility)</b>이 생긴다. 그리고 책임을 다하기 위한 데이터와 프로세스를 가지고 있다.   

<b>협력(Collaboration)</b>: 시스템 목표를 달성하기 위해 여러 객체가 참여하여 행동하는 것 (예. 치킨을 튀겨서 손님에게 배달해야 한다.)   
<b>책임(Responsibility)</b>: 협력 속에서 본인이 수행해야 할 임무의 내용을 알고, 수행하는 것 (예. 치킨을 튀길 객체는 치킨을 맛있게 조리할 책임을 갖는다.)   
<b>역할(Role)</b>: 동일한 목적을 가진 책임의 묶음 (예. 치킨을 조리할 책임을 가지는 역할은 요리사이다.)   

다시 확인하자면, <b>협력</b>은 문제 상황을 해결하기 위해 여러 객체가 참여하여 행동하는 것이며, <b>역할</b>을 맡으면 임무를 수행할 <b>책임</b>이 생긴다.   

치킨 배달의 예를 들어서 확인하자면
```
'치킨을 손님에게 배달하기'라는 "협력"을 완수하기 위해, "치킨 가게 객체"는 치킨을 튀기는 "책임(역할)"을 수행하고 "배달원 객체"는 손님에게 치킨을 전달하는 "책임(역할)"을 수행한다.
```

#### 메세지
* 객체는 '메세지'를 통해 다른 객체에 '책임'을 다하라고 요구한다.
* 메세지를 보내는 객체는 '무엇을' 할지만 요구하고, '어떻게' 하는지는 신경쓰지 않아도 된다.
* 객체는 '책임'을 수행하라고 요구받지만, 어떻게 처리할 지는 '자율'에 맡긴다.   

객체 구성 예시.
```
// 자바에서 메소드를 호출함으로써 메세지 보내기
class ChickenShop {
    // 메소드 이름과 리턴 타입은 메세지를 표현
    public void cookChicken() {
        // 치킨을 요리하라는 메세지를 받아 요리를 시작
        // 자기만의 방법으로 요리
    }

    public void deliverChicken() {
        // 치킨을 다른 객체에게 전달
    }
}
```

#### 자율성(의인화)
* 겍체지향과 현실세계의 차이점
    * 현실 세계의 치킨 가게는 건물에 불과 (현실 세계 모방을 넘어선다.)
    * 객체지향 세계의 치킨 가게는 스스로 치킨을 튀기고 치킨을 건낸다.
* 객체지향에서는 객체가 자율적으로 그리고 능동적으로 행동할 수 있다고 '의인화'해야 한다.
* 자율적으로 메세지를 처리하기 위해 자신의 책임을 수행하는 데 필요한 데이터와 프로세스를 가지고 있다.   

자율성 예시.
```
class ChickenShop {
    public void cookChicken() {
        // 스스로 치킨을 튀긴다.
    }

    public void deliverChicken() {
        // 치킨을 다른 객체에게 전달한다.
    }
}
```

#### 다형성
* 다형성을 활용하는 목적은 서로 다른 유형의 객체가 동일한 메세지에 대해 다르게 반응하기 위해서이다.
* 동일한 메세지를 처리한다 == 같은 역할을 수행한다
* 다르게 반응한다 == 메세지 처리 방법은 자율적이다   

```
class ElectricChickenShop extends ChickenShop {
    public void cookChicken() {
        // 똑같이 치킨을 요리하지만 어떤 치킨을 튀길지는 자율이다
    }

    public chicken getChicken() {
        // 전기구이 통닭을 리턴한다
    }
}
```

### 세줄 정리
1. 객체는 현실의 개념을 추상화한 것   
2. 객체들은 서로 협력하고, 역할을 맡아 책임을 수행하여 문제 상황을 해결   
3. 현실의 사물과 달리 객체는 능동적이고 자율적인 존재   

### 객체지향적으로 설계 - 책임 주도 설계
* 현실 세계를 반영하기 위한 설계를 시작하면 자칫 데이터 중심 설계를 하기 쉽다. 그러니 주의해야 한다.   

#### 데이터 중심 설계의 문제점
1. getter, setter가 과도하게 추가되어 결합도가 높아진다. 즉, 서로 알고 있는 객체가 많아진다. 결합도가 높아지면 하나의 변경이 일어났을 때, 다수의 수정이 필요하여 유지보수성이 떨어진다.   
2. 데이터를 처리하는 작업과 데이터가 분리되어 응집도가 낮아진다. (여러가지 이유로 변경이 되어야 한다.) 즉, 응집도가 낮다는 것은 한 가지 기능을 여러 객체가 같이 하고 있다는 것이다.   

### 데이터 중심 설계가 아닌 객체지향 설계 개발 - 책임 주도 개발
* 시스템이 사용자에게 제공해야 하는 기능인 시스템 책임을 파악
* 시스템 책임을 더 작은 책임으로 분할
* 분할된 책임을 수행할 수 있는 적절한 객체 또는 역할을 찾아 책임을 할당
* 객체가 책임을 수행하는 도중 다른 객체의 도움이 필요한 경우 이를 책임질 적절한 객체 또는 역할 찾기
* 해당 객체 또는 역할에게 책임을 할당함으로써 두 객체가 협력   

```
시스템이 사용자에게 제공해야 하는 기능인 시스템 책임을 파악 (달성하고자 하는 협력)
=> 치킨 주문을 받아서 손님에게 배달
```

```
시스템 책임을 더 작은 책임으로 분할
=> 메세지를 생성
    * 치킨 주문을 받는다
    * 치킨을 요리한다
    * 치킨을 손님에게 배달한다
```

```
분할된 책임을 수행할 수 있는 적절한 객체 또는 역할을 찾아 책임을 할당
=> 치킨 주문을 받는 것을 가게에게 역할 부여
```

```
객체가 책임을 수행하는 도중 다른 객체의 도움이 필요한 경우 이를 책임질 적절한 객체 또는 역할 찾기
=> 치킨 가게가 요리사에게 치킨을 요리하라고 전달, 요리사는 치킨을 배달하라고 배달원에게 전달

치킨 가게 --치킨을 요리하라--> 요리사 --치킨을 배달하라--> 배달원
```
도메인 설계를 해 나가면서 어떤 도출된 책임들을 어떤 객체한테 맡겨야 하는지 매핑한 다음 실제로 책임을 할당하면 된다. 책임을 할당하는 것은 메세지를 주는 것이기 때문이며 메세지는 메소드를 통해 표현이 된다.   

```
해당 객체 또는 역할에게 책임을 할당함으로써 두 객체가 협력

class ChickenShop {
    private Chef chef = new Chef();

    // 요리사에게 요리해달라고 메세지 요청
    public void takeOrder() {
        chef.cook();
    }
}

class Chef {
    private Driver driver = new Driver();
    private Chicken chicken;

    public void Cook() {
        chicken = new FriedChicken(); // 치킨 튀기기
        driver.deliver(chicken); // 배달원에게 배달 요청
    }
}

class Driver {
    public void deliver(Chicken chicken) {
        // 배달
    }
}
```

책임 주도 개발을 하면 유지보수성을 지킬 수 있기 때문에 효율성이 좋아진다. 책임 주도 설계를 자세히 알기 위해 <b>grasp 패턴</b>을 학습하는 것이 좋다.   

[출처](https://www.youtube.com/watch?v=3etKkkna-f0&t=25s)