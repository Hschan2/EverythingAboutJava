# Replication
<b>Replication</b>은 ```한 서버에서 다른 서버로 데이터를 동기화```하는 것을 말한다. 원본 데이터를 가진 서버를 <b>소스 서버</b>라고 하며 복제된 데이터를 가진 서버를 <b>레플리카(Replica) 서버</b>라고 한다.   

## Replication를 사용하는 이유
기본적으로 ```데이터 베이스의 부하를 줄이기 위해서``` 사용한다. 그러나 많은 서비스들이 데이터 베이스의 부하가 생길 만큼 많은 사용자가 있는 것이 아니다. 그래서 Replication 서버를 구축하는 목적은 다음과 같다.   

* <b>스케일 아웃</b>
    * 갑자기 늘어나는 트래픽을 대응하는데 유연한 구조
* <b>데이터 백업</b>
    * 레플리카르 하지 않더라도 백업 필수
    * 백업 과정은 실제 실행중인 쿼리들에 영향을 줄 수 있는 가능성 존재 (처리 속도 저하)
    * 레플리카 서버에서 데이터 백업을 실행하여 소스 서버에서 백업 시 발생하는 문제들을 해결 가능
* <b>데이터 분석</b>
    * 분석용 쿼리는 대량의 데이터를 조회하고 쿼리 자체가 무거운 경우가 존재
    * 레플리카 서버에서 분석용 쿼리만 전용으로 하는 것을 추천
* <b>데이터의 지리적 분산</b>
    * 데이터 베이스와 애플리케이션 서버가 머릴 떨어져 있다면 응답이 늦음
    * 빠른 응답을 위해 애플리케이션 서버에 가깝게 서버를 구성하는 것을 추천 (예. 넷플릭스가 미국에만 서버를 두었다면 한국 사용자들은 느린 사용을 하게 된다.)   

## 복제하는 방법
* <b>바이너리 로그</b>: MySQL 서버에서 발생하는 모든 변경 사항을 별도의 로그 파일에 순서대로 저장
    * 데이터의 변경 내역
    * 데이터 베이스나 테이블의 구조 변경
    * 계정이나 권한의 변경 정보
    * [예시 화면](https://youtu.be/95bnLnIxyWI?t=197)   

이러한 과정은 3개의 스레드에서 동작한다. Binary Log Dump Thread에서 한 개 그리고 나머지 두 개는 Replication I/O Thread에서 동작한다.   
* <b>Binary Log Dump Thread</b>: Binary Log를 레프리카 서버로 전송하는 역할
    * 레플리카 서버가 소스 서버에 연결되면 소스 서버에서 내부적으로 Binary Log Dump Thread를 생성한다.
* <b>Replication I/O Thread</b>: Binary Log Event를 가져와서 로컬 서버의 파일(Relay Log)로 저장하는 역할
    * Connection Metadata: 소스 서버에 연결할 때 사용하는 정보를 가지고 있으며 mysql.slave_master_info 테이블에 저장한다.
    * Relay Log: 가져온 Binary Log Event를 레플리카 서버에 파일로 저장한 것이다.
    * MySQL 데이터 디엑토리에 파일 형태로 저장된다.
* <b>Replication SQL Thread</b>: Relay Log 파일의 이벤트들을 읽고 실행
    * Applier Metadata: 소스 서버에 연결할 때 사용하는 정보를 가지고 있으며 mysql.slave_relay_log_info 테이블에 저장한다.   

## 변경 내용을 식별하는 방법
변경 내용을 식별하는 방법은 다음과 같다.   

* <b>Binary Log 파일 위치 기반</b>: 레플리카 서버에서 소스 서버의 Binary Log 파일명과 파일 내에서 위치로 Binary Log Event 식별하여 복제
    * 중요한 것은 MySQL 서버의 <b>server-id</b>이다.
* <b>글로벌 트랜잭셔녀 ID 기반(GTID)</b>: 복제에 참여한 서버들에서 고유하도록 각 이벤트에 부여된 식별값으로 소스 서버에서 발생한 각 이벤트들이 복제에 참여한 모든 서버들에서 동일한 고유 식별값을 가지는 것
    * 장애가 발생하여도 손쉽게 복제 토폴로지를 변경이 가능하다.
    * 장애 복구에 소요되는 시간이 줄어든다.

기본적으로 MySQL 복제를 사용하기 위해서는 소스 서버에서 반드시 Binary Log가 활성화가 되어 있어야 한다.   

# Binary Log 방식 (바이너리 로그는 어떻게 생겼는가?)
* <b>Statement 방식</b>: SQL문을 Binary Log에 그대로 기록
    * 트랜잭션 격리 수준이 반드시 ```REPEATABLE-READ``` 이상이어야 한다.
    * 손쉽게 SQL문을 확인할 수 있다.
    * 비확정적(delete / update에 order by 없이 limit 사용 등 => 매번 결과가 달라지는 상황)으로 처리될 수 있는 쿼리가 실행된 경우 Statement 포맷에서는 복제 시 소스 서버와 레플리카 서버 간 데이터가 달라질 수 있다.
* <b>Row 방식</b>: 변경된 데이터 자체를 Binary Log에 기록
    * MySQL 5.7.7 버전 이후부터 Binary Log 기본 포맷이다.
    * 어떤 형태의 쿼리든 복제 시 소스 서버와 레플리카 서버의 데이터를 일관되게 하여 안정적이다.
    * 많은 데이터를 변경하면 모든 데이터가 전부 기록되어 Binary Log 파일이 단 시간에 매우 커진다.
    * 어떤 쿼리가 넘어왔는지 현재 실행중인 쿼리가 무엇인지 레플리카 서버에서 확인할 수 없다.
* <b>Mixed 방식</b>: Statement 방식과 Row 방식을 혼합
    * ```binlog_format = 'MIXED'```로 하여 사용이 가능하다.
    * 대부분 Statement 방식으로 기록이 되어 복제되는 경우가 많지만 문제가 될 가능성이 있는 안전하지 않는 쿼리일 경우 Row 방식으로 변환되어 기록한다.

```mysql> set global binlog_format = 'STATEMENT'```와 같은 형식으로 방식을 변경할 수 있다.   

## 복제 동기화 방식
* <b>비동기 복제</b>: 소스 서버가 레플리카 서버에서 변경 이벤트가 정상적으로 전달되었는지 확인하지 않음
    * 소스 서버에서 에러가 발생할 경우 최근까지 적용된 트랜잭션이 레플리카 서버로 전송되지 않을 가능성이 존재한다.
* <b>반동기 복제</b>: 소스 서버는 레플리카 서버가 소스 서버로부터 전달받은 변경 이벤트를 Relay Log에 기록하고 나서 응답을 보내면 그 때 트랜잭션을 완전히 커밋하고 클라이언트에 결과 반환
    * 레플리카 서버에 보내는 하나의 트랜잭션이 보장되지만 이는 보장만 될 뿐 실제로 보내는 것까지 보장하는 것은 아니다.
    * 서버의 응답을 기다리기 때문에 트랜잭션 처리 속도가 느리다.   

## 소스 서버와 레플리카 서버 구성
* <b>싱글 레플리카 복제</b>: 하나의 소스 서버 + 하나의 레플리카 서버의 복제 형태
    * 소스 서버에서 문제가 발생할 경우 예비 서버로 읽기 용도로 사용한다.
* <b>멀티 레플리카 복제</b>: 하나의 소스 서버 + 두 개의 레플리카 서버의 복제 형태
    * 위와 마찬가지로 하나의 레플리카 서버는 예비용이며 다른 하나의 레플리카 서버는 읽기용이다.
* <b>체인 복제</b>: 하나의 소스 서버 + 여러 개의 레플리카 서버에서 Binary Log를 읽고 전달하는 작업에 부하가 발생할 경우 사용하는 복제 형태
    * 소스 서버가 해야할 Binary Log 배포 역할을 새로운 서버에 넘길 수 있다.
* <b>듀얼 소스 복제</b>: (소스 서버 + 레플리카 서버) + (소스 서버 + 레플리카 서버)의 복제 형태
    * 두 서버 모두 쓰기가 가능하다.
    * 두 서버는 서로 동일한 데이터를 갖는다.
    * ACTIVE-PASSIVE 형태와 ACTIVE-ACTIVE 형태를 가질 수 있다.
    * 하나의 서버가 문제가 발생했을 경우 전환을 바로 가져갈 수 있다.
* <b>멀티 소스 복제</b>: 하나의 레플리카 서버가 둘 이상의 소스 서버를 갖는 복제 형태
    * 여러 서버에 존재하는 다른 데이터를 하나의 서버로 통합하거나 샤딩(큰 데이터 베이스나 네트워크 시스템을 여러 조각으로 나누어 분산 저장)이 되어있는 테이블 데이터를 하나의 테이블로 통합할 때 사용이 가능하다.   

[Replication](https://www.youtube.com/watch?v=95bnLnIxyWI)