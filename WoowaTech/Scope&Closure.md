# Scope & Closure

## Scope (스코프)
변수 이름, 함수 이름, 클래스 이름과 같은 <b>식별자</b>가 본인이 선언된 위치에 따라 다른 코드에서 ```자신이 참조될 수 있을지 없을지 결정```되는 것이다.   

### 함수의 중첩
```
전역
    함수 -> 외부 함수 (중첩 함수 포함)
        함수 -> 중첩 함수
```

함수가 중첩이 돠는 것은 각각 함수의 지역 스코프도 중첩이 된다는 의미이다. 이는 스코프가 함수의 중첩에 의해 계층적인 구조를 가질 수 있다는 것을 의미한다.   

```
var x = "나는 전역 변수 x";

function outer() { // outer scope
    var y = "나는 outer 함수의 y";
    console.log(x); // 나는 전역 변수 x
    console.log(y); // 나는 outer 함수의 y

    function inner() { // inner scope
        var x = "나는 inner 함수의 x";
        console.log(x); // 나는 inner 함수의 x
        console.log(y); // 나는 outer 함수의 y
    }

    inner();
}

outer();
console.log(x); // 나는 전역 변수 x
console.log(y); // ReferenceError
```

찾고자 하는 스코프가 최상위. 즉, 전역 변수에도 찾을 수 없을 때, ReferenceError를 발생시킨다.   

### 스코프 체인
현재 함수가 어떤 변수를 참조하기 위해 현재 스코프 확인하고 없다면 상위 스코프. 상위 스코프에도 없다면 최상위 스코프를 확인하는 것이며, 변수를 참조할 때는 무조건 위로 올라간다.   

하위 스코프에서 상위 스코프에 있는 변수를 참조할 수 있는 이유는 스코프 체인의 반방향성 때문이다. 

### 스코프 레벨
* 블록 레벨 스코프: if문, for문, 함수 등이며 대부분 프로그래밍 언어가 해당
* 함수 레벨 스코프: 함수만 가능하며 자바스크립트가 해당된다.   

그러나 ES6 이후에는 <b>let</b>, <b>const</b>를 이용하여 if문, for문, 함수 등 블록 레벨 스코프를 사용할 수 있다.   

### 상위 스코프가 결정되는 시점
* 함수가 호출되는 시점에 결정 -> 동적 스코프   
프로그램 런타임 도중에 실행 컨텍스트나 호출 컨텍스트에 의해 스코프가 결정된다.   

* 함수가 정의되는 시점에 결정 -> 정적 스코프 (렉시컬 스코프)   
자바스크립트는 렉시컬 스코프를 따른다. 자바스크립트에서 함수는 생성되면서 자신의 내부 슬롯에 상위 스코프의 참조를 저장한다.   

즉, 자바스크립트에서 함수는 생성되면 본인의 내부 슬롯에 상위 스코프에 대한 참조를 저장한다.   


```
함수 호출
-> 실행 컨텍스트 생성 (자바스크립트 엔진에 의해)
-> 실행 컨텍스트 스택에 Push
-> 렉시컬 환경 생성 (포함하는 식별자, 식별자에 바인딩 된 값, 상위 렉시컬 환경에 대한 참조)
-> 코드 실행 완료 후, 실행 컨텍스트 스택에서 Pop하여 제거
```

```
const x = 1;

function outer() {
    const x = 10;
    const inner = function () {
        console.log(x);
    };

    return inner;
}

const ella = outer();
ella();

console.log>
10
```
위의 내용대로 코드를 분석하게 되면, x = 10의 값을 참조할 수가 없다. 그러나 결과값은 10이 나온다. 그 이유를 알기 위해 Closure(클로저)를 이해하자.   

## Closure (클로저)
```
const x = 10

outer
    inner -> 중첩 함수
```

중첩 함수 inner가 이미 생명 주기를 마감한 outer 함수. 즉, 내부 함수의 지역 변수 x를 <b>참조</b>할 수 있다면 이 때, inner를 <b>Closure (클로저)</b>라고 한다.   

```
const x = 1;

function outer() {
    const x = 10;
    const inner = function () {
        console.log(x);
    };

    return inner;
}

const ella = outer();
ella();

console.log>
10
```
즉, 이 코드에서 지역 변수 x를 참조하고 있는 inner 함수는 클로저가 된다.   

inner 함수가 클로저가 될 수 있는 이유를 영상으로 확인하기
[영상 13:00](https://www.youtube.com/watch?v=PVYjfrgZhtU)   

정리하자면, 중첩 함수가 ```상위 스코프```의 식별자를 <b>참조</b>하고 있고 본인의 외부 함수보다 더 오래 살아있다면 Closure (클로저)라고 한다.   

그리고 클로저에 의해 참조된 변수는 <b>자유 변수</b>라고 한다. 클로저는 하나의 state가 의도치 않게 변경되지 않도록 state를 안전하게 <b>은닉</b>하고 특정 함수에게만 state 변경을 허용하기 위해 사용한다고 한다.