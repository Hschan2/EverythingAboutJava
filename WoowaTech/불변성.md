# 불변성
<b>불변성</b>은 변하지 않는다는 것을 말하며 함수형 프로그래밍에서 가장 중요한 개념 중 하나이다.   

## 자바스크립트의 불변성
자바스크립트에서의 원시타입은 <b>불변</b>하고, 참조타입은 <b>가변적</b>이다.   

* 자바스크립트 데이터 타입
    * 원시 타입
        * Number
        * String
        * Boolean
        * Null
        * Undefined
        * Symbol
    * 참조 타입
        * Array
        * Object
        * Function
        * Date
        * RegExp
        * Map
        * Set   

자바스크립트에서의 원시 타입은 <b>불변</b>하다라는 말은 <b>메모리상 데이터 값</b>은 불변하다라는 말이다.   

반대로 참조 타입이 가변적인 이유는 <b>변수의 값</b>들이 가변적이기 때문이다.   

즉, 원시 타입이 변수 영역에서 데이터 영역의 주소값을 바로 저장한 형태와 달리 참조 타입은 변수 영역 - 데이터 영역 - 변수 영역 - 데이터 영역 형태로 구성이 된다. 즉, 변수 영역에는 어떤 값이든 넣을 수 있다.   

그러나 오브젝트의 데이터 영역은 주소 범위를 저장하기 때문에 이전의 오브젝트의 일부 값을 변경한다면 이전의 오브젝트의 데이터를 갖고 있는 다른 변수의 해당 데이터도 변경이 된다.   

즉, 참조 타입 내 데이터 영역의 값들은 불변하지만, 변수 영역의 값들은 가변적이다.   

## 불변성을 유지하는 이점
* 예측 가능성 (Predictable)
* 성능 효율성 (Efficiency)
    * 메모리 영역 성능
        * 여러 개의 변수 영역이 생긴다면 데이터 영역에서도 그와 같은 개수만큼 생긴다. => 비효율적
    * 상태 변경 추적 성능
        * 변수 존재여부 확인, 변수의 데이터 영역으로 이동, 데이터 값 비교가 아닌 변수 존재 여부 확인과 변수의 참조값 비교를 할 수 있다. => 오버헤드 부하 방지

## 변수의 불변함
```
let a = 1;
```
변수를 선언할 때, 이름 <b>a</b>는 가변이며 값인 <b>1</b>은 불변이다. 그렇다면 이름 <b>a</b>를 불변으로 유지할 수 있는 방법은 무엇일까?   

* const로 선언
    * 변수를 상수와 같이 작동. 재할당, 재선언 불가
* Object.freeze()
    * 오브젝트를 freeze하여 객체 속성의 수정, 추가, 제거가 불가능하게 설정
    * 엄격 모드 ("user strict")로 설정한다면 Type Error가 발생
    * 속성 추가 X, 속성 수정 X, 속성 삭제 X
    * 객체 내 객체 변경 방지를 못한다는 단점 존재 => 호출된 객체의 직속 속성들만 동결 (얕은 동결 (Swallow Freeze))
        * 깊은 동결로 하기 위해서는 객체를 재귀적으로 돌며 Object.freeze를 하는 방식 (반복) => 성능 저하
* Object.seal()
    * 속성 추가 X, 속성 수정 O, 속성 삭제 X
* Object.preventExtensions()
    * 속성 추가 X
    * 속성 수정 O
    * 속성 삭제 O   

이를 해결해주기 위한 라이브러리는 다음과 같다.   

* immutable.js
    * 객체, 배열을 선언할 때 Map, List를 이용해서 선언
    * 속성 값의 변화가 있으면 반드시 새로운 객체를 반환 (기존 객체 변경 X)

## 결론
* 일반적으로 자바스크립트의 불변성은 메모리 상 <b>데이터 영역의 불변성</b>을 의미
* 불변성은 <b>예측 가능성, 성능 효율성</b> (메모리 영역과 변화 추적)에 좋음
* <b>변수</b>도 불변성을 유지 가능 (<b>const</b>, <b>object.freeze</b>, <b>immutable.js</b>)   
   
* 메모리 상 변수 영역과 데이터 영역이 나누어진 이유
    * 데이터는 타입에 따라 필요한 영역의 크기가 다름
    * 타입과 상관없이 데이터를 넣으면 (데이터 크기가 가변적일 경우) <b>기존 영역의 크기가 부족하면 메모리 상 뒤에 있는 데이터들을 옮겨 줘야하는 작업 필요</b>
    * 그러나 이 과정은 성능상 비효율적   
   
* 데이터 중 더 이상 참조되는 변수가 없을 경우에 어떻게 되는가?
    * 가비지 콜렉터 (Garbage Collector)가 해당 데이터를 삭제   
   
* const obj ={}; const obj2 ={}; console.log(obj === obj2);
    * false
    * 참조 타입의 변수는 할당된 주소 범위가 기록된 데이터를 가리키고, obj와 obj2가 가르키는 주소 범위는 다르기 때문에 false   
   
* 객체를 복사할 때의 불변성
    * const obj2 = obj;
        * 한 변수의 속성이 변경되면 다른 변수의 속성도 변경
    * Object.assign({}, obj);
        * 얕은 복사, 현재 depth의 대해서는 불변성 보장
    * JSON.parse(JSON.stringify(obj));
        * 깊은 복사, 새로운 메모리 영역에 할당하는 방식   
   

[불변성](https://www.youtube.com/watch?v=eV4Yzssr9MA)