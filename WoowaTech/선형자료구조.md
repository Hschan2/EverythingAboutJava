# 선형 자료구조

자료 구조를 선택할 때는 요구 사항에 맞는 적절한 자료 구조를 선택해야 한다.   

* 고려할 점
    * 속도
    * 메모리
    * 등   

## 선형 자료구조 종류
* 동적 배열(Dynamic Array)
* 연결 리스트 (Linked List)
* 큐 (Queue)
* 스택 (Stack)
* 덱 (Dequeue)   

### 동적 배열(Dynamic Array)
배열의 크기를 자동으로 재할당하는 배열이다.   

* ArrayList
* Vector
* Array
* list   

### 배열의 한계
배열은 연속적인 메모리에 저장되는 특징을 갖고 있어 특정 상황에서 비율적으로 동작한다.   

* 중간의 데이터를 저장하는 경우
    * 중간에 데이터를 넣기 위해서 기존 데이터의 값을 뒤로 이동시켜야 하는 비효율적
* 중간의 데이터를 삭제하는 경우
    * 하나의 데이터를 삭제하기 위해 뒤의 데이터를 앞으로 가져와야 하는 비효율적

### 연결 리스트 (Linked List)
연속된 공간에 데이터를 저장하지 않을 때 연결 리스트를 사용한다. 연결 리스트는 데이터와 다음 저장된 데이터의 주소를 함께 기억하는 것이 특징이다.   

연결 리스트의 하나의 데이터는 노드라고 불리우며 값이 담긴 데이터와 다음 데이터의 주소가 담긴 노드로 구성되어 있다.   

#### 연결 리스트 (Linked List) - 순회
데이터의 <b>Head</b>로 시작하여 다음 노드까지 계속 확인한다. 마지막 노드에서는 다음 노드가 없기 때문에 <b>null</b>값을 가리키게 된다.   

#### 연결 리스트 (Linked List) - 추가
배열에서 기존 데이터를 뒤로 이동하고 데이터를 추가하는 것이 아니라 추가하고 싶은 위치에 데이터가 포함된 새로운 노드를 추가하면 된다.   

만약 첫 번째에 새로운 노드가 추가를 할 때 기존 <b>head</b>를 첫 번째 노드에 이동시키면 된다.   

#### 연결 리스트 (Linked List) - 식제
삭제하고자 하는 노드가 있다면 이를 가리키고 있는 <b>head</b>를 삭제하고자 하는 노드의 다음 노드를 가리키게 만들고 해당 노드를 삭제를 하면 된다.

### Circular Linked List (원형 연결 리스트)
기존 연결 리스트는 마지막 노드를 확인하기 위해 모든 노드를 확인해야 했지만 이를 해결하기 위해 나온 방법이다.   

마지막 노드가 첫 번째 노드를 바라보게 만들고 <b>head</b> 대신에 마지막 노드라는 것을 알기 위해 <b>tail</b>을 기억하도록 한다. 그래서 마지막 데이터가 필요할 경우 <b>tail</b>을 살펴보면 되며 첫 번째 데이터가 필요하다면 <b>tail</b>의 next를 확인하면 된다.   

### Doubly Linked List (이중 연결 리스트, 양방향 연결 리스트)
노드에서 <b>next</b> 뿐만 아니라 <b>previous</b>를 갖고 있다. 다음 노드를 가리킬 수 있고 이전 노드 또한 가리킬 수 있는 장점을 갖고 있다.   

이중 연결 리스트(양방향 연결 리스트)는 기존과 달리 역순으로도 탐색이 가능하다.

## 동적 배열 vs 연결 리스트
* 연결 리스트보다 동적 배열을 더 자주 사용한다.
    * 연결 리스트는 조회 속도가 느리다.
    * 연결 리스트는 중간에 추가와 삭제하는 동작의 비용이 있다.
    * 연결 리스트는 다음 노드를 기억하는데에 추가 메모리를 사용한다.
    * 연결 리스트는 메모리가 퍼져 있어 캐시의 효과를 누리지 못한다.
    * 연결 리스트는 잦은 추가와 삭제가 이뤄질 경우 사용하는 것이 좋다.
    * 다른 자료구조를 공부하는 기반 지식이 된다.   

## 큐 (Queue)
먼저 들어온 데이터가 먼저 나가는 것으로 이해하면 좋다.   

기존 데이터가 있는 경우에 새로 추가된 데이터는 뒤에 붙는다. 이러한 연산을 <b>Dequeue</b>라고 부른다.   

즉, Queue에서 가장 오래된 데이터가 빠져나가는 연산을 Dequeue라고 부른다.   

Queue는 배열과 연결 리스트로 구현할 수 있다.
```
class Queue {
    LinkedList list;

    void enqueue(int data) {
        list.addFirst(data);
    }

    int dequeue() {
        return list.popLast();
    }
}
```

연결 리스트로 구현을 하게 된다면 추가와 삭제가 쉽기 때문에 리스트가 가지고 있는 메소드 호출만 하면 Queue 구현을 할 수 있다. 그러나 배열을 주로 사용한다. 배열을 사용하게 된다면 메모리를 효율적으로 사용할 수 있고 성능적으로 이점을 갖게 된다.   

## 스택 (Stack)
나중에 들어온 데이터가 먼저 나가는 것을 말한다.   

데이터를 넣는 것을 <b>Push</b>라고 하며 데이터를 꺼내는 것을 <b>Pop</b>이라고 한다.   

스택은 주로 배열로 구현한다.

## 덱 (Double-Ended-Queue)
양쪽 끝으로 데이터를 넣고 빼는 것이 자유로운 특징을 가지고 있다.   

addFirst, AddLast | removeFirst, removeLast와 같은 연산을 사용한다.   

연결 리스트로 구현이 가능하지만 좋은 성능을 위해서 주로 배열을 사용한다.   

[선형 자료구조](https://www.youtube.com/watch?v=xnURecIJk4g)