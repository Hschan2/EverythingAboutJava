# 프론드엔드에서 에러 핸들링

## 들어가기 전, 에러란?
<b>오류 (에러)</b>란, 실패 혹은 실수 또는 오차를 말하며 하드웨어의 고장 또는 소프트웨어가 본래의 동작을 할 수 없는 상태를 말한다.   

* 소프트웨어가 본래의 동작을 할 수 없는 상태
    * 컴파일 오류
        * 코드가 컴파일 될 때 컴파일러가 해석하지 못해서 발생
    * 런타임 오류
        * 프로그램이 동작할 때 발견할 수 있는 에러   

## 자바스크립트
자바스크립트는 프로그램이 동작할 때 실시간으로 Type이 결정되어 모든 에러가 컴파일 단계가 아닌 런타임 환경에서 에러가 발생한다.   

여기서 타입스크립트를 제대로 활용한다면 런타임 전에 미리 알 수 있는 오류도 있다. 만약 타입스크립트를 사용한다면 에러의 발생을 방지할 수 있는 방어 코드를 작성하는 습관을 가지고 있어야 한다.   

## 예외
<b>예외</b>란, 일반적인 규칙이나 정례에서 벗어나는 일을 말하며 런타임 오류와 관련된 것이고 예상하기 어렵거나 예상이 불가능한 이슈를 의미한다.   

* 예상하기 어렵거나 예상이 불가능한 이슈
    * 오류가 발생할 수도 아닐 수도 있는 것을 ```예외``` 구문으로 처리하여 프로그램이 예상치 못하게 종료되거나 제 기능을 못하는 것을 방지
    * 예외로 인해 발생한 <b>Error 객체</b>를 핸들링하는 것을 <b>에러 핸들링</b>
    * 런타임 환경에서의 에러, <b>예외</b>   

## 에러 핸들링이 필요한 이유
* 에러에 대한 상황을 인지시키기, 다른 행동을 할 수 있도록 유도 => 서비스에 대한 부정적인 경험을 막기
* 서비스의 트랜잭션에 영향을 미쳐 장애를 일으킬 수 있는 상황이 발생하는 것을 막기
* 예. 로그인 시도 => 일정 시간이 넘음 => 로그인 실패 메세지, 재시도 요청   

## 에러의 분류
* 해결 가능한 에러 & 예측할 수 없는 에러
    * 일시적인 네트워크 에러
* 해결 가능한 에러 & 예상 가능한 에러
    * 인증 에러
    * 잘못된 접근으로 인한 에러
    * 애플리케이션에서 정의한 에러
* 예측할 수 없는 에러 & 해결 불가능한 에러
    * 브라우저에서 발생하는 에러
    * 서비스 장애 상황
* 예상 가능한 에러 & 해결 불가능한 에러
    * 사용자의 고의적인 에러
    * 악의적인 목적의 접근 또는 사용   

### 예상이 가능한 에러
* 인증 에러
* 없는 페이지를 접근했을 때의 에러
* 애플리케이션에서 정의한대로 API 응답의 상태 코드로 예측할 수 있는 에러
* 악의적인 목적으로 접근했을 때 이를 보완하는 코드가 프로그램에 내제되어 있지 않는 경우   

### 예상이 불가능한 에러
* 서비스 장애
* 일시적인 네트워크가 불안정한 상황에서 발생하는 에러
* 상태코드 500대 에러   

## Try-catch-finally
* Try: 에러가 발생할 수도 있는 로직 작성, 에러를 직접 throw 할 수 있다.
* Catch: 에러를 잡는다.
* Finally: 로직의 성공과 실패 여부와 상관없이 무조건 실행이 된다.   

```
const crewNickname = "티키타카";

openStudyLog();

try {
    writeStudying(crewNickname);
} catch (error) {
    console.error("등록된 팀원이 아닙니다.");
} finally {
    closeStudyLog();
}
```

## 에러 핸들링 예시
* 비동기 API 통신에서의 에러 핸들링
    * 400 (요청 오류)
        * 예. 엑세스 토큰이 없는 페이스북에 요청을 할 경우, 400 에러와 함께 에러 메세지, 에러 타입, 에러 코드와 특정한 키 값을 표시
        * 페이스북 홈페이지에서 오류 응답에 관한 컨벤션을 확인하여 해결 방안 찾기
    * 500 (서버 오류)
* 잘못된 페이지나 없는 페이지를 접근할 때
    * 커스텀한 404 에러 페이지를 보여주거나 다른 페이지로 리다이렉트하는 방법을 사용하여 해당 페이지에 접근할 수 없음을 전달
* 예상할 수 없는 에러 - 모니터링
    * 일시적인 에러임을 알리기
    * 고객센터에 연락할 수 있는 창구 마련하기
    * 개발자의 주기적인 모니터링을 통해 같은 에러가 발생하는 것을 방지하기 위해 예외처리 하기 (예. 센트리(Sentry) 도구)   

## 에러 핸들링에 대한 고찰
* 무조건 Try-catch 하는 것을 지양할 것
    * catch에 넘겨지는 error 객체의 타입을 보장할 수 없음 (분기 처리를 하지 않을 경우 명확하게 파악 불가능)
    * 오류를 해결하는 것이 아닌 숨기는 것으로 더욱 좋지 않은 방향으로 이어짐
    * 코드의 가독성이 떨어지고 유지보수가 어려움
        * 성공하는 여부에 대해서만 다루고 실패하는 경우에는 외부에 위임하는 것도 가독성과 유지보수에 좋은 방법
    ```
    가독성이 떨어지는 문제 예시.

    const checkAuth = async (accessToken) => {
        try {
            let user;
            try {
                user = await login(accessToken);
            } catch (error) {
                throw new Error(error, "존재하지 않은 유저");
            }

            return await getRole(user);
        } catch (error) {
            console.error(error, "권한이 없는 유저");
        }
    };
    ```

    ```
    수정한 예시.

    const checkAuth = async (accessToken) => {
        const user = await login(accessToken);
        const role = await getRole(user);
        return role;
    }

    const UserPage = () => {
        ...

        try {
            checkAuth(accessToken);
        } catch (error) {
            console.error(ERROR_MESSAGE(error.code) ?? ERROR_MESSAGE.DEFAULT);
        }
    };
    ```
    * 유의미한 에러를 내보낼 수 있는 범위에서 에러 핸들링할 것
    * 유의미한 결과를 내보낼 수 없다면, 에러를 터뜨릴 것
* 그 외
    * 리엑트에서 선언적으로 에러 핸들링 하는 방법
    * golang을 사용하여 tuple 방식으로 에러 핸들링 하는 방법
    * 함수형 프로그래밍을 통해 에러 핸들링 하는 방법

[프론드엔드 에러 핸들링](https://www.youtube.com/watch?v=FXtooPhupr4)