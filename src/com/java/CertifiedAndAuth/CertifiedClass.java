package com.java.CertifiedAndAuth;

public class CertifiedClass {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		
//		인증
//		서비스에 등록된 유저의 신원을 입증하는 과정
//		
//		예. 게시판 서비스에 필요한 회원 가입과 로그인
//		인증하기 == 로그인 하기 
//		
//		Request Header 방식으로 진행하자면
//			* HTTP에서 무상태성 (클라이언트의 요청은 그 다음 요청과 관계가 없다)
//		
//		1. 클라이언트의 로그인 요청이 들어오면 브라우저에서 Base64 인코더를 이용해서 인코딩 후 전달하는 방식 -> 그 다음 요청 헤더 Authorization에 넣어서 보내 주는 개념
//		2. HTTP로 서버로 전달하고 데이터 베이스에 값을 체크하고 실제 값이 있으면 True 넘김
//			BUT Request Header만 사용하면 인증이 필요할 때마다 계속 인증해야 한다는 것. 매번 인증을 해야 한다. => 브라우저의 힘을 빌린다. 브라우저의 스토리지 (쿠키, 세션)
//			클라이언트 요청 부분은 해킹에 취약. 서버에 도움을 요청하여 보안을 잡는다. => 세션 이용 -> 서버를 이용하면 사용자의 RAW 데이터를 가지고 있지 않아 위험하지 않고 세션 만료 기간을 정할 수 있다
//			BUT 위 부분도 서버가 여러 개일 때 문제 발생 서버는 하나 하나 자체 세션을 관리하기 때문에 다른 서버로 요청할 시 오류 발생 -> 세션스토리지로 해결 가능 (세션스토리지란 서버들의 세션을 한 곳에서 관리하자)
//			BUT 이럼에도 클라이언트가 다수일 경우 문제 발생. 짧은 시간 동안 많은 요청이 올 경우 스토리지에 문제 발생 
//			WHY HTTP 도움은 무상태성을 기초로 하지만 위에 과정은 사용자의 정보와 상태를 클라이언트 서버 데이터 베이스가 모두 가지고 있는 상태성으로 서로 충돌
//			SO 요청과 응답을 하는 것에 사용자의 상태를 담는 것. 즉, 토큰을 이용하는 것 => JWT
//			
//		3. JSON WEB TOKEN (JWT)
//		비밀키를 사용해 JWT를 생성하고 비밀키를 사용해 JWT 인증 과정을 거친다
//		해석하기 쉽기 때문에 비밀번호 같은 중요한 정보가 담긴 것은 사용 X
//		클라이언트가 요청하고 서버가 받고 그리고 데이터 베이스에서 체크하는 것을 토큰을 이용한다. (비밀키를 이용해 요청과 응답을 받는 형태)
//		토큰의 비밀키가 유요하다면 사용자 정보 파악을 진행 (반대로 유효하지 않다면 버림) => 사용자 이름, 토큰 만료 시기, 권한 등을 파악
//		
//		장점
//		세션과 달리 로드밸런서가 보내는 것을 각자 가지고 있는 비밀키로 해독하여 인증 과정을 거친다
//		서버가 기존에서 더 늘어나도 똑같이 진행이 가능하다
//		
//		단점
//		해킹을 당할 수 있고 해커가 권한을 가져 사용할 수 있음 -> 토큰의 만료 기간을 정해 해킹 위험을 줄이기 -> 그러나 사용자 본인도 사용 불가
//		=> 이를 해결하는 것이 리프레시토큰
//		
//		리프레시토큰
//		위 과정과 같지만 서버가 엑세스토큰과 리프레시토큰을 동시 생성하고 토큰을 저장할 때 엑세스토큰은 저장하지 않고 리프레시토큰을 저장
//		그리고 이를 헤더로 보내 클라이언트에서 두 개 모두 저장
//		
//		핵심
//		토큰으로 상태 관리를 하기 때문에 따로 세션을 둘 필요 없음 => 효율성 증가, 속도 빠름
//		토큰 관리가 필수. 토큰도 빼앗길 수 있기 때문
//		
//		추가
//		OAUTH(추천), HTTPONLY, SSL/TLS1.3(가성비 및 배우기 쉬운 보안 방법, 추천)
			
	}

}
