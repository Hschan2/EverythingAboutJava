package com.java.ProcessThread;

public class ProcessClass {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		
//		프로세스
//		운영 체제 위에서 실행중인 프로그램, 프로그램 명령어와 데이터들이 메모리에 올라오고 실행 중 또는 실행 대기중인 상태
//		
//		프로세서
//		프로세스가 동작될 수 있도록 하는 하드웨어(CPU)
//		
//		멀티태스킹
//		CPU(프로세서)는 한 순간에 하나의 프로세스만 실행할 수 있음 -> 운영 체제가 짧은 시간에 수십번~수천번 실행할 프로세스를 교체하여 동시에 수행하는 것처럼 느낌
//		
//		프로세스를 제어하기 위한 정보 모음
//			- 프로세스 식별자 (Process ID)
//			- 프로세스 상태
//			- 다음에 실행할 명령어의 주소
//			- 이전에 작업하던 내용 (레지스터)
//			- CPU 스케줄링 정보(우선 순위, 최정 실행시각, CPU 점유 시간 등)
//			- 프로세스의 주소 공간 등
//			
//		Context Switching
//		ex. 두 개의 문서 중 하나가 진행 상태에서 준비 상태로 빠진다는 정보와 또 다른 하나가 어디까지 진행됐는지 어디서부터 시작하면 되는지 정보에 대해 로딩할 시간이 필요하고  그 순간
//		
//		프로세스 구조
//		스택(stack) - 호출된 함수, 지역변수 등 임시 데이터
//		힙(heap) - 동적으로 생긴 데이터. new Object(), malloc()...
//		데이터(data) - 전역변수. static 변수, global 변수
//		코드(code) - 프로그램의 코드
//		
//		멀티 프로세스
//			단점 1. 비효율 => 첫 번재 프로세스가 진행하는 동안 실제 일을하는 코어로 로딩 => 그 다음 프로세스가 실행될 때 똑같이 실제로 일을하는 코어가 로딩되기 때문에 이전 프로세스를 내리고 새로운 코드들로 로딩하는 작업이 필요,
//							똑같은 역할을 하는 두 개의 프로세스가 있더라도 각각 영역을 따로 가지기 때문에 다른 프로세스를 이용하기 위해서는 통신이 필요
	}

}
