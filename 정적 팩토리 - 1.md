# 생성자 대신 정적 팩토리를 고려하기 - 정적 팩토리 장점 첫 번째

## 생성자 대신 정적 팩토리 메서드를 고려하기
* 장점
    * 이름을 가질 수 있다.
        * 동일한 시그니처의 생성자를 두 개 이상 가질 수 없다.
        ```
        private boolean prime;
        private boolean urgent;
        private Product product;

        public Order(Product product, boolean prime) {
            this.product = product;
            this.prime = prime;
        }

        public Order(Product product, boolean urgent) {
            this.product = product;
            this.urgent = urgent;
        }

        => 에러 발생. 똑같은 매개 변수의 타입과 개수로 인해
        그러나 매개 변수의 순서를 바꾸면 에러가 발생하지 않지만 사용하지 않아야 한다. 이보다 정적 팩토리를 사용한다. 이럴 경우, 기존 생성자는 삭제

        public static Order primeOrder(Product product) {
            Order order = new Order();
            order.prime = true;
            order.product = product;
            return order;
        }

        public static Order urgentOrder(Product product) {
            Order order = new Order();
            order.urgent = true;
            order.product = product;
            return order;
        }
        ```
    * 호출될 때마다 인스턴스를 새로 생성하지 않아도 된다.
        * Boolean, valueOf
    ```
    public class Settings {
        private boolean useAutoSteering;
        private boolean useABS;
        private Difficulty difficulty;

        public static void main(String[] args) {
            System.out.println(new Settings());
            System.out.println(new Settings());
            System.out.println(new Settings());
        }

        => 매번 다른 인스턴스가 생성이 된다. 그러나 특정한 경우에만 생성할 지 결정해야 한다. 여러 개의 인스턴스가 있으면 안되고 유일한 인스턴스가 있어야 한다는 상황일 때 정적 팩토리를 활용해 인스턴스를 통제할 수 있다.
    }

    public class Settings {

        private Settings() {

        }

        private static final Settings SETTINGS = new Settings();

        public static Settings newInstance() {
                return SETTINGS;
        }
    }

    => 생성자를 private로 설정하고 인스턴스를 private static final로 생성한다. 그리고 newInstance를 생성한다. 외부 함수에서 사용하기 위해서는 newInstance를 사용해야 하는 방법밖에 없다. 그리고 매번 새로운 인스턴스가 생성되는 것이 아닌 유일 인스턴스가 생성된다.

    public class Product {
        Settings settings1 = Settings.newInstance();
        Settings settings2 = Settings.newInstance();
    }

    => Settings의 newInstance로 인스턴스를 생성했고 여러 번 생성해도 모두 같은 인스턴스인 것을 확인할 수 있다. 생성자로는 접근할 수 없고 제어가 불가능하다. 객체 자체를 자기 자신이 통제한다는 것을 의미한다. 기본 생성자가 있는 경우에는 사용하는 곳에서 언제든지 사용이 가능하다.
    
    Boolean.valueOf(false);

    => 매개 변수에 따라 각기 다른 인스턴스를 Return하는 경우가 정적 팩토리를 사용하면 가능하다.

    그리고 플라이웨이트 패턴도 이와 비슷한 개념이다.
    ```
    * 반환 타입의 하위 타입 객체를 반환할 수 있는 능력이 있다.
        * 인터페이스 기반 프레임워크, 인터페이스에 정적 메소드
    * 입력 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수 있다.
        * EnumSet
    * 정적 팩토리 메서드를 작성하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 된다.
        * 서비스 제공자 프레임워크   

* 단점
    * 상속을 하려면 public 혹은 protected 생성하기 필요하니 정적 팩토리 메서드만 제공해야 한다.
    * 정적 팩토리 메서드는 프로그래머가 찾기 어렵다.   

[정적 팩토리 장점 - 1](https://www.youtube.com/watch?v=P-HQ9ab9fc0)